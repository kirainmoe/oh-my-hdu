题意就是整数划分嘛，给定一个整数 n，求 n 有多少种分法，然后不能重复。

一开始都没想到是 DP 题……为什么可以用 DP 呢，一定是因为有重复计算的步骤啦。比如说我们要划分整数 4，把 4 划分到 3+1 的时候，显然 3 还能再往下划分，那么我们就可以直接利用之前已经计算过的结果了。

也算是个好题吧，据说还有母函数的做法，但是没有深究。网上现成的 DP 题解大概有两种说法，但是状态转移方程是一样的。这个方程挺好写，但是不好想。

第一种解法是设 dp[i][j] 为将整数 i 划分为**最多 j 个数的和**的时候最多的方案数量。我觉得这种方案不太好理解，尤其是分类讨论的时候。所以以下分析以第二种解法为基础：设 dp[i][j] 为将整数 i 划分为**不超过 j 的数的和**的时候最多的方案数量。

    1. 显然，当 i = 1 的时候，区间长度只能是 1，那么只有一种方法，也即 dp[1][1] = 1.

    2. 当 i < j 的时候，由于不可能出现“目标数是 i，但是 j(j > i) 是 i 的一个加数”的情况，所以我们让 dp[i][j] = dp[i][i].

    3. 当 i = j 的时候，dp[i][j] = dp[i][j-1] + 1

      (1) 用不超过 j 的整数划分的时候，我们考虑是否要分出 j 这个数，如果要分的话由于 n = m 那么只有一种方案，就是 m 本身（对应状态转移方程中的 1），如果不分，那么就是继承 dp[i][j-1] 的结果，即把 i 分成最大加数不超过 j-1 的多少份。

      (2) 如果我们用第一种解法来理解这个式子，那么 dp[i][j] = 将 i 分成 j-1 段的方案数最大值 + 将 i 分成 j 段的方案数，由于 i = j，那么将 i 分成 j 段只有一种方案，就是有 j 个 1 的情况。

    4. 当 i > j 的时候，也是最不好理解的一个部分。这个时候我们可以发现一个包含 i 个数的集合 U={1, 2, 3, ..., i} 可以被 j 划分为两部分：一个是 A={j}，一个是 CU(A). 那么这个时候我们可以考虑是否要分出 j 这个数：如果要分出 j，那么我们只要计算剩下来的数的分离方案数，就是 dp[i-j][j]；如果不分，那么答案还是把 i 分成不超过 j-1 的结果，也就是 dp[i][j-1]. 将两种方案相加，我们得到了 dp[i][j] = dp[i-j][j] + dp[i][j-1];

"这样我们就完美地解决了这个问题。"