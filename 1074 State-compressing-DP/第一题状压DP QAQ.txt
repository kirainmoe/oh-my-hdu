嘛……这是我有生以来写过的第一道状态压缩 DP 的题……第一眼看到 N <= 15 就有种不好的预感 2333……

状态压缩嘛，就是把 DP 中用到的状态用二进制来表示，然后就这道题目理解了一下状态压缩 DP 的基本的写法，下面是我稍微总结的一下状态压缩 DP 的框架：

const MAXN = 最大的状态点数目
const MAXS = 1 << MAXN			// 最多的状态数，表示 2^MAXN 个
var dp[MAXS]				// DP 数组

read n

for (i = 1...(1 << n))			// 枚举每个用二进制表示的状态
    for (j = 0....n)			// 枚举每一个点
        var cur = 1 << j		// 当前点用二进制表示后的整数
	if (i & cur)			// 判断当前状态是否合法，即当前枚举的状态 (i) 必须包含当前枚举的点 (cur)
            var last = i - cur		// 这一步是可选的，如果你要获得当前状态的上一个状态
					// 那么可以用当前枚举的状态减去当前枚举的点的二进制状态

            dp equation			// 那么现在就可以开始你的 DP 方程了

print dp[(1 << n) - 1]			// 最终答案就是 dp[(1 << n) - 1] 了

然后说回到这一题上吧。题意就是某人要做好多的作业，每个作业有一个上交期限 deadline 和需要花费的时间 cost。如果每超过一天上交就扣一分，然后让你求出扣分最少的方案并输出字典序最小的方案。

由于最多只有 15 个状态点，那么用二进制表示这 15 个状态点的话，十进制的数不会超过 2^15 = 32768，所以我们想到用状压 DP 来解。那么，设整数 i 为用二进制表示了当前状态然后转换后的十进制数，然后我们就可以开一个数组 dp[1...MAXS] 来表示对于每个状态扣的分最少是多少，这里我们用二进制来表示状态，即用 0 来表示未完成这个作业，1 表示已完成这个作业。然后我们就可以从低位向高位填充来表示是否坐过这个作业了。

例如说有 5 门作业，你做了 第一门、第二门和第五门，那么用二进制表示就是 10011，然后转成十进制数就是 19.

我们用 i 枚举当前状态，然后再枚举一维 j 表示当前枚举的状态点（每一科的作业），当 i 状态包含了当前状态点的时候我们就可以根据我们的 DP 方程对 dp 数组进行更新。具体地，我们可以判断 i & (1 << j) 是否等于 1 的结果来看，如果等于 1 的话那么 i 状态就完成了第 j 门功课。

dp 方程如下（不要忘记转移的同时更新时间）：

	dp[i].score = dp[prev].score + max(dp[prev].time + lesson[j].cost - lesson[j].deadline, 0)

我们记 curscore = 在完成第 j 门作业前的上一个状态（可以用 i - (1 << j) 来求得上一个状态）已经花费掉的时间 + 做当前作业需要花费的时间 - 当前作业的 deadline，那么 curscore 有两种情况：1. 当 curscore > 0 的时候，就是当前决策会被扣掉的分数；2. 当 curscore <= 0 的时候，表明当前决策还不会被扣分，但是提早上交作业也不会加分，所以我们要把它设为 0.

然后呢看题目要求除了输出最小代价之外还要输出方案，那么我们可以用一个结构体来表示当个状态，除了记录代价 score 和所用时间 times 外还需要记录上一个状态 prev 和当前的科目 subject. 利用最终答案是 dp[(1 << n) - 1] 这个性质，我们就可以通过 prev 回溯回去输出方案了，具体的做法就是从最终状态往前搜寻，并把它们加入一个栈中。然后你知道怎么做了。

还有一个要注意的地方就是边界处理，不然会无限 WA。